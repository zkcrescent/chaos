// File generated by gorpgen. DO NOT EDIT.
package sample

import (
	"encoding/json"
	"github.com/juju/errors"
	"github.com/zkcrescent/chaos/gorp-util"
	"gopkg.in/gorp.v2"
)

func init() {
	gorpUtil.Tables.Add(TableC{})
}

var (
	TableC_Field = gorpUtil.TableField("table_c", "field")
	TableC_ID    = gorpUtil.TableField("table_c", "id")
)

func (t TableC) Fields() []string {
	return []string{
		"table_c.field",
		"table_c.id",
	}
}

func (t TableC) Sharding() int64 {
	return 0
}

func (t TableC) TableName() string {
	if t.Sharding() <= 0 {
		// no sharding key return basic table name
		return "table_c"
	}

	return "table_c"

}

func (t TableC) VersionField() string {
	return ""
}

func (t TableC) PK() (*gorpUtil.Field, interface{}) {
	return TableC_ID, t.ID
}

func (t *TableC) Relation(edge string) (*gorpUtil.Field, bool) {
	return nil, false
}

func (t *TableC) Load(db gorp.SqlExecutor, pk int64) error {
	return errors.Annotatef(t.Where(
		TableC_ID.EQ(pk),
	).Fetch(db), "pk:%d", pk)
}

// Insert TableC to db
func (t *TableC) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *TableC) Insert(db gorp.SqlExecutor) error {

	err := db.Insert(t)
	if err != nil {
		return errors.Annotate(db.Insert(t), t.String())
	}

	return nil
}

// Update TableC to db
func (t *TableC) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *TableC) Update(db gorp.SqlExecutor) error {

	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

// Remove mark TableC is remove(not actually delete)

// Delete TableC from db
func (t *TableC) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *TableC) Delete(db gorp.SqlExecutor) error {
	_, err := db.Delete(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

func (t *TableC) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
	return "", nil, nil, false
}

func (t *TableC) Where(cs ...*gorpUtil.Condition) *gorpUtil.Query {
	return gorpUtil.Get(t).Where(cs...)
}
func (t *TableC) Rel(m gorpUtil.Model, edge string) *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(m, edge)
}
func (t *TableC) Rels(rs ...*gorpUtil.Relation) *gorpUtil.Query {
	return gorpUtil.Get(t).Rels(rs...)
}

// json string
func (t *TableC) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

// pagination
type TableCPageResp struct {
	*gorpUtil.PageResponse
	Data []*TableC `db:"data" json:"data"`
}

func (t *TableCPageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func LoadTableCPage(tx gorp.SqlExecutor, resp *TableCPageResp, q *gorpUtil.Query, page *gorpUtil.Page) error {
	resp.Data = make([]*TableC, 0)
	total, err := gorpUtil.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = gorpUtil.NewPageResponse(page, total, resp.Data)
	return nil
}
