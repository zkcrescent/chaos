// File generated by gorpgen. DO NOT EDIT.
package sample

import (
	"encoding/json"
	"fmt"
	"github.com/juju/errors"
	"github.com/zkcrescent/chaos/gorp-util"
	"gopkg.in/gorp.v2"
)

func init() {
	var t TableAC
	if t.Sharding() > 0 {
	} else {
		gorpUtil.Tables.Add(TableAC{})
	}
}

var (
	TableAC_AID = gorpUtil.TableField("table_ac", "aid")

	TableAC_CID = gorpUtil.TableField("table_ac", "cid")

	TableAC_Field = gorpUtil.TableField("table_ac", "field")

	TableAC_ID = gorpUtil.TableField("table_ac", "id")
)

func (t TableAC) Fields() []string {
	return []string{

		"table_ac.aid",

		"table_ac.cid",

		"table_ac.field",

		"table_ac.id",
	}
}
func (t TableAC) Field_aid() string {
	return fmt.Sprintf("%v.aid", t.TableName())
}
func (t TableAC) Field_cid() string {
	return fmt.Sprintf("%v.cid", t.TableName())
}
func (t TableAC) Field_field() string {
	return fmt.Sprintf("%v.field", t.TableName())
}
func (t TableAC) Field_id() string {
	return fmt.Sprintf("%v.id", t.TableName())
}

func (t TableAC) Sharding() int64 {
	return 0
}

func (t TableAC) TableName() string {
	if t.Sharding() <= 0 {
		// no sharding key return basic table name
		return "table_ac"
	}

	return "table_ac"

}

func (t TableAC) BasicTableName() string {
	return "table_ac"
}

func (t TableAC) VersionField() string {
	return ""
}

func (t TableAC) PK() (*gorpUtil.Field, interface{}) {
	return TableAC_ID, t.ID
}

func (t *TableAC) Relation(edge string) (*gorpUtil.Field, bool) {
	return nil, false
}

func (t *TableAC) Load(db gorp.SqlExecutor, pk int64) error {
	return errors.Annotatef(t.Where(
		TableAC_ID.EQ(pk),
	).Fetch(db), "pk:%d", pk)
}

// Insert TableAC to db
func (t *TableAC) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableAC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *TableAC) Insert(db gorp.SqlExecutor) error {

	err := db.Insert(t)
	if err != nil {
		return errors.Annotate(db.Insert(t), t.String())
	}

	return nil
}

// Update TableAC to db
func (t *TableAC) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableAC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *TableAC) Update(db gorp.SqlExecutor) error {

	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

// Remove mark TableAC is remove(not actually delete)

// Delete TableAC from db
func (t *TableAC) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableAC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *TableAC) Delete(db gorp.SqlExecutor) error {
	_, err := db.Delete(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

func (t *TableAC) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
	return "", nil, nil, false
}

func (t *TableAC) Where(cs ...*gorpUtil.Condition) *gorpUtil.Query {
	return gorpUtil.Get(t).Where(cs...)
}
func (t *TableAC) Rel(m gorpUtil.Model, edge string) *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(m, edge)
}
func (t *TableAC) Rels(rs ...*gorpUtil.Relation) *gorpUtil.Query {
	return gorpUtil.Get(t).Rels(rs...)
}

// json string
func (t *TableAC) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

// pagination
type TableACPageResp struct {
	*gorpUtil.PageResponse
	Data []*TableAC `db:"data" json:"data"`
}

func (t *TableACPageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func LoadTableACPage(tx gorp.SqlExecutor, resp *TableACPageResp, q *gorpUtil.Query, page *gorpUtil.Page) error {
	resp.Data = make([]*TableAC, 0)
	total, err := gorpUtil.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = gorpUtil.NewPageResponse(page, total, resp.Data)
	return nil
}
