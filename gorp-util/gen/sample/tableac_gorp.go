// File generated by gorpgen. DO NOT EDIT.
package sample

import (
	"encoding/json"
	"fmt"
	"github.com/juju/errors"
	"github.com/zkcrescent/chaos/gorp-util"
	"gopkg.in/gorp.v2"
)

func init() {
	var t TableAC
	if t.Sharding() > 0 {
		gorpUtil.Tables.Add(TableAC{ID: 0 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 1 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 2 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 3 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 4 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 5 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 6 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 7 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 8 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 9 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 10 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 11 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 12 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 13 + 1})
		gorpUtil.Tables.Add(TableAC{ID: 14 + 1})
	} else {
		gorpUtil.Tables.Add(TableAC{})
	}
}

var (
	TableAC_AID   = gorpUtil.ShardTableField("table_ac", "aid", 15)
	TableAC_CID   = gorpUtil.ShardTableField("table_ac", "cid", 15)
	TableAC_Field = gorpUtil.ShardTableField("table_ac", "field", 15)
	TableAC_ID    = gorpUtil.ShardTableField("table_ac", "id", 15)
)

func (t TableAC) Fields() []string {
	return []string{
		fmt.Sprintf("%v.aid", t.TableName()),
		fmt.Sprintf("%v.cid", t.TableName()),
		fmt.Sprintf("%v.field", t.TableName()),
		fmt.Sprintf("%v.id", t.TableName()),
	}
}

func (t TableAC) Field_AID() *gorpUtil.Field {
	return TableAC_AID(t.Shard())
}

func (t TableAC) Field_CID() *gorpUtil.Field {
	return TableAC_CID(t.Shard())
}

func (t TableAC) Field_Field() *gorpUtil.Field {
	return TableAC_Field(t.Shard())
}

func (t TableAC) Field_ID() *gorpUtil.Field {
	return TableAC_ID(t.Shard())
}

func (t TableAC) Shard() int64 {
	return t.ID
}
func (t *TableAC) SetShard(shard int64) *TableAC {
	t.ID = shard
	return t
}

func (t TableAC) Sharding() int64 {
	return 15
}

func (t TableAC) TableName() string {
	if t.Sharding() <= 0 {
		// no sharding key return basic table name
		return "table_ac"
	}

	if t.ID < 1 {
		panic("sharding key ID smaller than 1")
	}
	return fmt.Sprintf("table_ac_%v", t.ID%t.Sharding())

}

func (t TableAC) BasicTableName() string {
	return "table_ac"
}

func (t TableAC) VersionField() string {
	return ""
}

func (t TableAC) PK() (*gorpUtil.Field, interface{}) {
	return TableAC_ID(t.ID), t.ID
}

func (t *TableAC) Relation(edge string) (*gorpUtil.Field, bool) {
	return nil, false
}

func (t *TableAC) Load(db gorp.SqlExecutor, pk int64) error {
	return errors.Annotatef(t.Where(
		TableAC_ID(t.ID).EQ(pk),
	).Fetch(db), "pk:%d", pk)
}

// Insert TableAC to db
func (t *TableAC) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableAC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *TableAC) Insert(db gorp.SqlExecutor) error {

	err := db.Insert(t)
	if err != nil {
		return errors.Annotate(db.Insert(t), t.String())
	}

	return nil
}

// Update TableAC to db
func (t *TableAC) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableAC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *TableAC) Update(db gorp.SqlExecutor) error {

	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

// Remove mark TableAC is remove(not actually delete)

// Delete TableAC from db
func (t *TableAC) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableAC) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *TableAC) Delete(db gorp.SqlExecutor) error {
	_, err := db.Delete(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

func (t *TableAC) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
	return "", nil, nil, false
}

func (t *TableAC) Where(cs ...*gorpUtil.Condition) *gorpUtil.Query {
	return gorpUtil.Get(t).Where(cs...)
}
func (t *TableAC) Rel(m gorpUtil.Model, edge string) *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(m, edge)
}
func (t *TableAC) Rels(rs ...*gorpUtil.Relation) *gorpUtil.Query {
	return gorpUtil.Get(t).Rels(rs...)
}

// json string
func (t *TableAC) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

// pagination
type TableACPageResp struct {
	*gorpUtil.PageResponse
	Data []*TableAC `db:"data" json:"data"`
}

func (t *TableACPageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func LoadTableACPage(tx gorp.SqlExecutor, resp *TableACPageResp, q *gorpUtil.Query, page *gorpUtil.Page) error {
	resp.Data = make([]*TableAC, 0)
	total, err := gorpUtil.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = gorpUtil.NewPageResponse(page, total, resp.Data)
	return nil
}
