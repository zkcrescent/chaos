// File generated by gorpgen. DO NOT EDIT.
package sample

import (
	"encoding/json"
	"fmt"
	"github.com/juju/errors"
	"github.com/zkcrescent/chaos/gorp-util"
	"gopkg.in/gorp.v2"
)

func init() {
	gorpUtil.Tables.Add(TableA{})
}

var (
	TableA_Field = gorpUtil.TableField("table_a", "field")
	TableA_ID    = gorpUtil.TableField("table_a", "id")
)

// Edge names
const (
	REL_TABLEA_EDGEA = "edgeA"
	REL_TABLEA_EDGEB = "edgeB"
)

// Relation objects
var (
	Rel_TableA_TableB_edgeA = gorpUtil.R(new(TableB), "edgeA")
	Rel_TableB_TableA_edgeA = gorpUtil.R(new(TableA), "edgeA")
	Rel_TableA_TableB_edgeB = gorpUtil.R(new(TableB), "edgeB")
	Rel_TableB_TableA_edgeB = gorpUtil.R(new(TableA), "edgeB")
)

const (
	MUL_TABLEA_EDGEA = "edgeA"
)

func (t TableA) Fields() []string {
	return []string{
		"table_a.field",
		"table_a.id",
	}
}

func (t TableA) Sharding() int64 {
	return 1
}

func (t TableA) TableName() string {
	if t.Sharding() <= 0 {
		// no sharding key return basic table name
		return "table_a"
	}

	if t.ID < 1 {
		panic("sharding key ID smaller than 1")
	}
	return fmt.Sprintf("table_a_%v", t.ID%t.Sharding())

}

func (t TableA) VersionField() string {
	return ""
}

func (t TableA) PK() (*gorpUtil.Field, interface{}) {
	return TableA_ID, t.ID
}

func (t *TableA) Relation(edge string) (*gorpUtil.Field, bool) {
	fm := map[string]*gorpUtil.Field{
		"edgeA": TableB_AID,
		"edgeB": TableB_AID,
	}
	fk, ok := fm[edge]
	return fk, ok
}

func (t *TableA) Load(db gorp.SqlExecutor, pk int64) error {
	return errors.Annotatef(t.Where(
		TableA_ID.EQ(pk),
	).Fetch(db), "pk:%d", pk)
}

// Insert TableA to db
func (t *TableA) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableA) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *TableA) Insert(db gorp.SqlExecutor) error {

	err := db.Insert(t)
	if err != nil {
		return errors.Annotate(db.Insert(t), t.String())
	}

	return nil
}

// Update TableA to db
func (t *TableA) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableA) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *TableA) Update(db gorp.SqlExecutor) error {

	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

// Remove mark TableA is remove(not actually delete)

// Delete TableA from db
func (t *TableA) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *TableA) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *TableA) Delete(db gorp.SqlExecutor) error {
	_, err := db.Delete(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

func (t *TableA) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
	switch edge {
	case "edgeA":
		return "table_ac", TableAC_AID, TableAC_CID, true
	}
	return "", nil, nil, false
}

func (t *TableA) Where(cs ...*gorpUtil.Condition) *gorpUtil.Query {
	return gorpUtil.Get(t).Where(cs...)
}
func (t *TableA) Rel(m gorpUtil.Model, edge string) *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(m, edge)
}
func (t *TableA) Rels(rs ...*gorpUtil.Relation) *gorpUtil.Query {
	return gorpUtil.Get(t).Rels(rs...)
}

// Relations
func (t *TableA) Rel_edgeA() *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(new(TableB), "edgeA")
}
func (t *TableA) Rel_edgeB() *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(new(TableB), "edgeB")
}

// json string
func (t *TableA) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

// pagination
type TableAPageResp struct {
	*gorpUtil.PageResponse
	Data []*TableA `db:"data" json:"data"`
}

func (t *TableAPageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func LoadTableAPage(tx gorp.SqlExecutor, resp *TableAPageResp, q *gorpUtil.Query, page *gorpUtil.Page) error {
	resp.Data = make([]*TableA, 0)
	total, err := gorpUtil.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = gorpUtil.NewPageResponse(page, total, resp.Data)
	return nil
}
