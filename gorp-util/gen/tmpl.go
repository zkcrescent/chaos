package main

var tmpl = `{{ $dot := . }}
// File generated by gorpgen. DO NOT EDIT.
package {{.Pkg}}

{{- if .Imports }}
import (
{{- range $i := .Imports }}
    "{{$i}}"
{{- end }}
)
{{- end}}

{{- if .Init }}
func init() {
	var t {{.Name}}
	if t.Sharding() > 0 {
		{{- range  $idx, $v := .ShardingIdx }}
	  gorpUtil.Tables.Add({{$dot.Name}}{
		{{$dot.ShardKey}}: {{$idx}}+1,
	  })
	  	{{- end}}
	} else {
	  gorpUtil.Tables.Add({{.Name}}{})
	}
}

{{- end }}
var (
{{- range $f, $tf := .Fields }}
	{{if $dot.Sharding }}
	{{$dot.Name}}_{{$f}}   = gorpUtil.ShardTableField("{{$dot.Table}}", "{{$tf}}", {{$dot.Name}}{})
	{{else}}
	{{$dot.Name}}_{{$f}}    = gorpUtil.TableField("{{$dot.Table}}", "{{$tf}}")
	{{end}}
{{- end}}
)

{{ if .Rels}}
// Edge names
const (
{{- range $edge, $rel := .Rels}}
    REL_{{$dot.Name | ToUpper}}_{{$edge | ToUpper}} = "{{$edge}}"
{{- end}}
)

// Relation objects
var (
{{- range $edge, $rel := .Rels}}
    Rel_{{$dot.Name}}_{{$rel.Name}}_{{$edge}} = gorpUtil.R(new({{$rel.Name}}), "{{$edge}}")
    Rel_{{$rel.Name}}_{{$dot.Name}}_{{$edge}} = gorpUtil.R(new({{$dot.Name}}), "{{$edge}}")
{{- end}}
)
{{end}}

{{ if .Muls }}
const (
{{- range $mul := .Muls }}
    MUL_{{$dot.Name | ToUpper}}_{{$mul.Edge | ToUpper}} = "{{$mul.Edge}}"
{{- end}}
)
{{end}}

func (t {{.Name}}) Fields() []string {
	return []string{
{{- range $f, $tf := .Fields }}
		"{{$dot.Table}}.{{$tf}}",
{{- end}}
	}
}

func (t {{.Name}}) Sharding() int64 {
	return {{.Sharding}}
}

func (t {{.Name}}) TableName() string {
	if t.Sharding() <= 0 {
	// no sharding key return basic table name
		return "{{.Table}}"
	}

	{{ if .IsShardTable }} return fmt.Sprintf("{{.Table}}_%v", t.Shard()) {{else}}
{{ if eq .Sharding  0 }} return "{{.Table}}" {{ else }}
	if t.{{.ShardKey}} < 1 {
		panic("sharding key {{.ShardKey}} smaller than 1")
	}
	return fmt.Sprintf("{{.Table}}_%v", t.{{.ShardKey}}%t.Sharding()){{ end }}

	{{ end }}
}

func (t {{.Name}}) BasicTableName() string {
	return "{{.Table}}"
}

func (t {{.Name}}) VersionField() string {
    return "{{.Version}}"
}

func (t {{.Name}}) PK() (*gorpUtil.Field, interface{}) {
	return {{.Name}}_{{.ID}}{{if .Sharding}}(t.{{.ID}}){{end}}, t.{{.ID}}
}

{{ if .Rels }}
func (t *{{.Name}}) Relation(edge string) (*gorpUtil.Field, bool) {
	fm := map[string]*gorpUtil.Field{
{{- range $edge, $rel := .Rels }}
	"{{$edge}}": {{$rel.Name}}_{{$rel.Field}},
{{- end }}
    }
    fk, ok := fm[edge]
    return fk, ok
}
{{ else }}
func (t *{{.Name}}) Relation(edge string) (*gorpUtil.Field, bool) {
	return nil, false
}
{{- end }}

func (t *{{.Name}}) Load(db gorp.SqlExecutor, pk int64) error {
	return errors.Annotatef(t.Where(
{{- if .Fields.Removed }}
		{{.Name}}_Removed.EQ(false),
{{- end }}
		{{.Name}}_{{.ID}}{{if .Sharding}}(t.{{.ID}}){{end}}.EQ(pk),
	).Fetch(db), "pk:%d", pk)
}

// Insert {{.Name}} to db
func (t *{{.Name}}) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Insert(db gorp.SqlExecutor) error {
{{ if .Fields.CreatedTime }}
	if !t.CreatedTime.Valid {
		t.CreatedTime = gorpUtil.Now()
	}
{{- end }}
{{- if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	err := db.Insert(t)
	if err != nil {
		return errors.Annotate(db.Insert(t), t.String())
	}

	return nil
}

// Update {{.Name}} to db
func (t *{{.Name}}) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Update(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

// Remove mark {{.Name}} is remove(not actually delete)
{{- if .Fields.Removed }}
func (t *{{.Name}}) RemoveWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre remove hook error")
		}
	}

	if err := t.Remove(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post remove hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Remove(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	t.RemovedTime = gorpUtil.Now()
{{- if .Fields.Removed }}
	t.Removed = true
{{- end }}
	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}
{{- end }}

// Delete {{.Name}} from db
func (t *{{.Name}}) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}	

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Delete(db gorp.SqlExecutor) error {
	_, err := db.Delete(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

{{ if .Muls }}
func (t *{{.Name}}) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
    switch edge {
{{- range $mul := .Muls }}
    	case "{{$mul.Edge}}":
    		return "{{$mul.TableName}}", {{$mul.Left.Name}}_{{$mul.Left.Field}}, {{$mul.Right.Name}}_{{$mul.Right.Field}}, true
{{- end }}
    }
	return "", nil, nil, false
}
{{ else }}
func (t *{{.Name}}) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
	return "", nil, nil, false
}
{{- end }}

func (t *{{.Name}}) Where(cs ...*gorpUtil.Condition) *gorpUtil.Query {
	return gorpUtil.Get(t).Where(cs...)
}
func (t *{{.Name}}) Rel(m gorpUtil.Model, edge string) *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(m, edge)
}
func (t *{{.Name}}) Rels(rs ...*gorpUtil.Relation) *gorpUtil.Query {
	return gorpUtil.Get(t).Rels(rs...)
}
{{- if .Rels}}
// Relations
{{- range $edge, $rel := .Rels}}
func (t *{{$dot.Name}}) Rel_{{$edge}}() *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(new({{$rel.Name}}), "{{$edge}}")
}
{{- end}}
{{end}}

// json string
func (t *{{$dot.Name}}) String() string {
    bs, _ := json.Marshal(t)
    return string(bs)
}

// pagination
type {{$dot.Name}}PageResp struct {
	*gorpUtil.PageResponse
	Data []*{{$dot.Name}} ` + "`" + `db:"data" json:"data"` + "`" + `
}

func (t *{{$dot.Name}}PageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func Load{{$dot.Name}}Page(tx gorp.SqlExecutor, resp *{{$dot.Name}}PageResp, q *gorpUtil.Query, page *gorpUtil.Page) error {
	resp.Data = make([]*{{$dot.Name}}, 0)
	total, err := gorpUtil.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = gorpUtil.NewPageResponse(page, total, resp.Data)
	return nil
}
`
