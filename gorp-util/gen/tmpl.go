package main

var tmpl = `{{ $dot := . }}
// File generated by gorpgen. DO NOT EDIT.
package {{.Pkg}}

{{- if .Imports }}
import (
{{- range $i := .Imports }}
    "{{$i}}"
{{- end }}
)
{{- end}}

{{- if .Init }}
func init() {
	var t {{.Name}}
	if t.Sharding() > 0 {
		{{- range  $idx, $v := .ShardingIdx }}
			{{ if $dot.IsShardTable }} gorpUtil.Tables.Add(t.ShardInit({{$idx}}+1).real()) {{else}} t.{{$dot.ShardKey}} = {{$idx}}+1
		gorpUtil.Tables.Add(t.real()) {{end}}
	  	{{- end}}
	} else {
	{{ if not .GlobalSharding }} gorpUtil.Tables.Add({{.Name}}{}) {{end}}
	}
}

{{- end }}
var (
{{- range $f, $tf := .Fields }}
	{{if $dot.Sharding }} {{$dot.Name}}_{{$f}}   = gorpUtil.ShardTableField("{{$dot.Table}}", "{{$tf}}", {{$dot.Sharding}}) {{else}} {{$dot.Name}}_{{$f}}    = gorpUtil.TableField("{{$dot.Table}}", "{{$tf}}")
	{{end}}
{{- end}}
)

{{ if .Rels}}
// Edge names
const (
{{- range $edge, $rel := .Rels}}
    REL_{{$dot.Name | ToUpper}}_{{$edge | ToUpper}} = "{{$edge}}"
{{- end}}
)

// Relation objects
var (
{{- range $edge, $rel := .Rels}}
    Rel_{{$dot.Name}}_{{$rel.Name}}_{{$edge}} = gorpUtil.R(new({{$rel.Name}}), "{{$edge}}")
    Rel_{{$rel.Name}}_{{$dot.Name}}_{{$edge}} = gorpUtil.R(new({{$dot.Name}}), "{{$edge}}")
{{- end}}
)
{{end}}

{{ if .Muls }}
const (
{{- range $mul := .Muls }}
    MUL_{{$dot.Name | ToUpper}}_{{$mul.Edge | ToUpper}} = "{{$mul.Edge}}"
{{- end}}
)
{{end}}

func (t {{.Name}}) Fields() []string {
	return []string{
{{- range $f := .FS }}
		t.Field_{{$f.FieldName}}().String(),
{{- end}}
	}
}


func (t {{.Name}}) FieldList() []*gorpUtil.Field {
	return []*gorpUtil.Field{
{{- range $f := .FS }}
		t.Field_{{$f.FieldName}}(),
{{- end}}
	}
}


func (t {{.Name}}) Values() []interface{} {
	return []interface{}{
{{- range $f := .FS }}
		t.{{$f.FieldName}},
{{- end}}
	}
}


{{- range $f, $tf := .Fields }}

func (t {{$dot.Name}}) Field_{{$f}}() *gorpUtil.Field {
	{{ if $dot.Sharding}} return	{{$dot.Name}}_{{$f}}(t.Shard()) {{else if $dot.GlobalSharding}} return	gorpUtil.TableField(t.TableName(), "{{$tf}}") {{else}} return {{$dot.Name}}_{{$f}} {{end}}
}
{{- end}}

{{if .Sharding }}
	{{- if .IsShardTable }}
	{{- else}}
func (t {{$dot.Name}}) Shard() int64 {
	return t.{{$dot.ShardKey}}%t.Sharding()
}
	{{- end}}
	{{- if .ShardKey}}
func (t *{{$dot.Name}}) SetShard(shard {{.ShardKeyTp}}) *{{$dot.Name}} {
	t.{{$dot.ShardKey}} = shard
	return t
}
	{{- end}}

func (t {{$dot.Name}}) SetAutoIncrement(db gorp.SqlExecutor) error {
	if _, err := db.Exec(
		fmt.Sprintf("set auto_increment_increment = %d", t.Sharding()),
	); err != nil {
		return errors.Annotate(err, "set auto_increment_increment to shard")
	}
	offset := t.Shard()
	if offset == 0 {
		offset = 16
	}
	if _, err := db.Exec(
		fmt.Sprintf("set auto_increment_offset = %d", offset),
	); err != nil {
		return errors.Annotate(err, "set auto_increment_off to shard")
	}
	return nil
}

func (t {{$dot.Name}}) UnsetAutoIncrement(db gorp.SqlExecutor) error {
	if _, err := db.Exec("set auto_increment_increment = 1"); err != nil {
		return errors.Annotate(err, "set auto_increment_increment to 1")
	}
	
	if _, err := db.Exec("set auto_increment_offset = 1"); err != nil {
		return errors.Annotate(err, "set auto_increment_off to 1")
	}
	return nil
}


func (t *{{.Name}}) ShardInsert(db gorp.SqlExecutor) error {
{{ if $dot.Fields.CreatedTime }}
	if !t.CreatedTime.Valid {
		t.CreatedTime = gorpUtil.Now()
	}
{{- end }}
{{- if $dot.Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	if err := t.SetAutoIncrement(db); err != nil {
		return err
	}
	tmp := t.Real()
	err := db.Insert(tmp)
	*t = tmp.Real()
	if err != nil {
		return err
	}
	if err := t.UnsetAutoIncrement(db); err != nil {
		return err
	}

	return nil
}

type {{$dot.Name}}Interface interface{
	Real() {{$dot.Name}}
}

{{- range  $idx, $v := .ShardingIdx }}
type {{$dot.Name}}{{$idx}} struct {
	{{$dot.Name}}
}

func (t *{{$dot.Name}}{{$idx}}) Real() {{$dot.Name}} {
	return t.{{$dot.Name}}
}
{{- end}}

func (t {{.Name}}) real() gorpUtil.Table {
	switch t.Shard() {
		{{- range  $idx, $v := .ShardingIdx }}
		case {{$idx}}:
			return {{$dot.Name}}{{$idx}}{t}
		{{- end}}
	}
	panic(fmt.Sprintf("cant get real type of {{.Name}} of shard %v", t.Shard()))
}


// Real for insert and upadte
func (t {{.Name}}) Real() {{.Name}}Interface {
	switch t.Shard() {
		{{- range  $idx, $v := .ShardingIdx }}
		case {{$idx}}:
			return &{{$dot.Name}}{{$idx}}{t}
		{{- end}}
	}
	panic(fmt.Sprintf("cant get real type of {{.Name}} of shard %v", t.Shard()))
}


{{end}}

func (t {{.Name}}) Sharding() int64 {
	return {{.Sharding}}
}

{{ if not .HasTableName }}
func (t {{.Name}}) TableName() string {
	if t.Sharding() <= 0 {
	// no sharding key return basic table name
		return "{{.Table}}"
	}

	{{ if .IsShardTable }} return fmt.Sprintf("{{.Table}}_%v", t.Shard()) {{else}}
{{ if eq .Sharding  0 }} return "{{.Table}}" {{ else }}
	if t.{{.ShardKey}} < 1 {
		panic("sharding key {{.ShardKey}} smaller than 1")
	}
	return fmt.Sprintf("{{.Table}}_%v", t.{{.ShardKey}}%t.Sharding()){{ end }}

	{{ end }}
}
{{ end }}

func (t {{.Name}}) BasicTableName() string {
	return "{{.Table}}"
}

func (t {{.Name}}) VersionField() string {
    return  "{{.Version}}"
}

func (t {{.Name}}) Version() int64 {
	{{ if .Version }} return t.{{.VersionKey}} {{else}} return 0 {{end}}
}


func (t {{.Name}}) NoPK() bool {
	return {{.NoPK}}
}

func (t {{.Name}}) PK() (*gorpUtil.Field, interface{}) {
	{{if .NoPK}}
	panic("table {{ .Name }} no pk")
	{{else}}
	return {{.Name}}_{{.ID}}{{if .Sharding}}(t.{{.ID}}){{end}}, t.{{.ID}}
	{{end}}
}

{{ if .Rels }}
func (t *{{.Name}}) Relation(edge string) (*gorpUtil.Field, bool) {
	fm := map[string]*gorpUtil.Field{
{{- range $edge, $rel := .Rels }}
	"{{$edge}}": {{$rel.Name}}_{{$rel.Field}},
{{- end }}
    }
    fk, ok := fm[edge]
    return fk, ok
}
{{ else }}
func (t *{{.Name}}) Relation(edge string) (*gorpUtil.Field, bool) {
	return nil, false
}
{{- end }}

func (t *{{.Name}}) Load(db gorp.SqlExecutor, pk int64) error {
{{if .NoPK}}
	panic("table {{ .Name }} no pk")
{{else}}
	return errors.Annotatef(t.Where(
{{- if .Fields.Removed }}
	{{if .Sharding }} {{.Name}}_Removed(t.Shard()).EQ(false), {{else}} {{.Name}}_Removed.EQ(false), {{end}}
{{- end }}
		{{.Name}}_{{.ID}}{{if .Sharding}}(t.{{.ID}}){{end}}.EQ(pk),
	).Fetch(db), "pk:%d", pk)
{{end}}
}

// Insert {{.Name}} to db
func (t *{{.Name}}) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Insert(db gorp.SqlExecutor) error {
{{ if .Fields.CreatedTime }}
	if !t.CreatedTime.Valid {
		t.CreatedTime = gorpUtil.Now()
	}
{{- end }}
{{- if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
{{if .Sharding}}
	tmp := t.Real()
	err := db.Insert(tmp)
	*t = tmp.Real()
{{else}}
	err := db.Insert(t)
{{end}}
	if err != nil {
		return err
	}

	return nil
}

// Update {{.Name}} to db
func (t *{{.Name}}) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Update(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
{{if .Sharding}}
	tmp := t.Real()
	_, err := db.Update(tmp)
	*t = tmp.Real()
{{else}}
	_, err := db.Update(t)
{{end}}
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

// Remove mark {{.Name}} is remove(not actually delete)
{{- if .Fields.Removed }}
func (t *{{.Name}}) RemoveWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre remove hook error")
		}
	}

	if err := t.Remove(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post remove hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Remove(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	t.RemovedTime = gorpUtil.Now()
{{- if .Fields.Removed }}
	t.Removed = true
{{- end }}
{{if .Sharding}}
	tmp := t.Real()
	_, err := db.Update(tmp)
	*t = tmp.Real()
{{else}}
	_, err := db.Update(t)
{{end}}
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}
{{- end }}

// Delete {{.Name}} from db
func (t *{{.Name}}) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}	

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Delete(db gorp.SqlExecutor) error {
{{if .Sharding}}
	tmp := t.Real()
	_, err := db.Delete(tmp)
	*t = tmp.Real()
{{else}}
	_, err := db.Delete(t)
{{end}}
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

{{ if .Muls }}
func (t *{{.Name}}) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
    switch edge {
{{- range $mul := .Muls }}
    	case "{{$mul.Edge}}":
    		return "{{$mul.TableName}}", {{$mul.Left.Name}}_{{$mul.Left.Field}}, {{$mul.Right.Name}}_{{$mul.Right.Field}}, true
{{- end }}
    }
	return "", nil, nil, false
}
{{ else }}
func (t *{{.Name}}) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
	return "", nil, nil, false
}
{{- end }}

func (t *{{.Name}}) Where(cs ...*gorpUtil.Condition) *gorpUtil.Query {
	return gorpUtil.Get(t).Where(cs...)
}
func (t *{{.Name}}) Rel(m gorpUtil.Model, edge string) *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(m, edge)
}
func (t *{{.Name}}) Rels(rs ...*gorpUtil.Relation) *gorpUtil.Query {
	return gorpUtil.Get(t).Rels(rs...)
}
{{- if .Rels}}
// Relations
{{- range $edge, $rel := .Rels}}
func (t *{{$dot.Name}}) Rel_{{$edge}}() *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(new({{$rel.Name}}), "{{$edge}}")
}
{{- end}}
{{end}}

// json string
func (t *{{$dot.Name}}) String() string {
    bs, _ := json.Marshal(t)
    return string(bs)
}

// pagination
type {{$dot.Name}}PageResp struct {
	*gorpUtil.PageResponse
	Data []*{{$dot.Name}} ` + "`" + `db:"data" json:"data"` + "`" + `
}

func (t *{{$dot.Name}}PageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func Load{{$dot.Name}}Page(tx gorp.SqlExecutor, resp *{{$dot.Name}}PageResp, q *gorpUtil.Query, page *gorpUtil.Page) error {
	resp.Data = make([]*{{$dot.Name}}, 0)
	total, err := gorpUtil.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = gorpUtil.NewPageResponse(page, total, resp.Data)
	return nil
}
`
