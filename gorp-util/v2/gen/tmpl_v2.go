package main

var tmplV2 = `{{ $dot := . }}
// File generated by gorpgen. DO NOT EDIT.
package {{.Pkg}}

{{- if .Imports }}
import (
{{- range $i := .Imports }}
    "{{$i}}"
{{- end }}
)
{{- end}}

{{- if .Init }}
func init() {
	gorpUtil.Tables.Add({{.Type}}{})
}

{{- end }}
var (
{{- range $f, $tf := .Fields }}
	{{$dot.Type}}_{{$f}}    = gorpUtil.TableField("{{$dot.Table}}", "{{$tf}}")
{{- end}}
)

{{ if .Rels}}
// Edge names
const (
{{- range $edge, $rel := .Rels}}
    REL_{{$dot.Type | ToUpper}}_{{$edge | ToUpper}} = "{{$edge}}"
{{- end}}
)

// Relation objects
var (
{{- range $edge, $rel := .Rels}}
    Rel_{{$dot.Type}}_{{$rel.Name}}_{{$edge}} = gorpUtil.R(new({{$rel.Name}}), "{{$edge}}")
    Rel_{{$rel.Name}}_{{$dot.Type}}_{{$edge}} = gorpUtil.R(new({{$dot.Type}}), "{{$edge}}")
{{- end}}
)
{{end}}

{{ if .Muls }}
const (
{{- range $mul := .Muls }}
    MUL_{{$dot.Type | ToUpper}}_{{$mul.Edge | ToUpper}} = "{{$mul.Edge}}"
{{- end}}
)
{{end}}

type {{.Type}} struct {
	{{.Name}}
	source {{.Name}} ` + "`db:\"-\" json:\"-\" yaml:\"-\"`" + `
}

func (t {{.Type}}) Fields() []string {
	return []string{
{{- range $f, $tf := .Fields }}
		"{{$dot.Table}}.{{$tf}}",
{{- end}}
	}
}

func (t {{.Type}}) GenVersion() string {
	return "{{.GenVersion}}"
}

func (t *{{.Type}}) DumpSource() {
	t.source = t.{{.Name}}
}

func (t {{.Type}}) ModelSource() {{.Name}} {
	return t.source
}

func (t {{.Type}}) TableName() string {
	return "{{.Table}}"
}

func (t {{.Type}}) VersionField() string {
    return "{{.Version}}"
}

func (t {{.Type}}) PK() (*gorpUtil.Field, interface{}) {
	return {{.Type}}_{{.ID}}, t.{{.ID}}
}

func (t {{.Type}}) VersionK() (*gorpUtil.Field, interface{}) {
{{ if .VersionKey }}
	return {{.Type}}_{{.VersionKey}}, t.{{.VersionKey}}
{{ else }}
	return nil, nil
{{ end }}
}

{{ if .Rels }}
func (t *{{.Type}}) Relation(edge string) (*gorpUtil.Field, bool) {
	fm := map[string]*gorpUtil.Field{
{{- range $edge, $rel := .Rels }}
	"{{$edge}}": {{$rel.Name}}_{{$rel.Field}},
{{- end }}
    }
    fk, ok := fm[edge]
    return fk, ok
}
{{ else }}
func (t *{{.Type}}) Relation(edge string) (*gorpUtil.Field, bool) {
	return nil, false
}
{{- end }}

func (t *{{.Type}}) Load(db gorp.SqlExecutor, pk int64) error {
	return errors.Annotatef(t.Where(
{{- if .Fields.Removed }}
		{{.Type}}_Removed.EQ(false),
{{- end }}
		{{.Type}}_{{.ID}}.EQ(pk),
	).Fetch(db), "pk:%d", pk)
}

// Insert {{.Type}} to db
func (t *{{.Type}}) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Type}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *{{.Type}}) Insert(db gorp.SqlExecutor) error {
{{ if .Fields.CreatedTime }}
	if !t.CreatedTime.Valid {
		t.CreatedTime = gorpUtil.Now()
	}
{{- end }}
{{- if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	err := db.Insert(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	t.DumpSource()

	return nil
}

// Update {{.Type}} to db
func (t *{{.Type}}) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Type}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *{{.Type}}) Update(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	t.DumpSource()

	return nil
}

// Update {{.Type}} to db
func (t *{{.Type}}) UpdateColumnsWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Type}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.UpdateColumns(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t {{.Type}}) UpdateColumnsFields() map[string]interface{} {
	fields := map[string]interface{}{}
{{- range $f, $tf := .Fields }}
	if t.{{$f}} != t.source.{{$f}} {
		fields["{{$tf}}"] = t.{{$f}}
	}
{{- end}}
	return fields
}

func (t *{{.Type}}) UpdateColumns(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}

	_, err := gorpUtil.UpdateColumns(db, t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	t.DumpSource()

	return nil
}

// Remove mark {{.Type}} is remove(not actually delete)
{{- if .Fields.Removed }}
func (t *{{.Type}}) RemoveWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Type}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre remove hook error")
		}
	}

	if err := t.Remove(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post remove hook error")
		}
	}

	return nil
}

func (t *{{.Type}}) Remove(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = gorpUtil.Now()
{{- end }}
	t.RemovedTime = gorpUtil.Now()
{{- if .Fields.Removed }}
	t.Removed = true
{{- end }}
	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}
{{- end }}

// Delete {{.Type}} from db
func (t *{{.Type}}) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Type}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}	

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *{{.Type}}) Delete(db gorp.SqlExecutor) error {
	_, err := db.Delete(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

{{ if .Muls }}
func (t *{{.Type}}) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
    switch edge {
{{- range $mul := .Muls }}
    	case "{{$mul.Edge}}":
    		return "{{$mul.TableName}}", {{$mul.Left.Name}}_{{$mul.Left.Field}}, {{$mul.Right.Name}}_{{$mul.Right.Field}}, true
{{- end }}
    }
	return "", nil, nil, false
}
{{ else }}
func (t *{{.Type}}) Multiple(edge string) (string, *gorpUtil.Field, *gorpUtil.Field, bool) {
	return "", nil, nil, false
}
{{- end }}

func (t *{{.Type}}) Where(cs ...*gorpUtil.Condition) *gorpUtil.Query {
	return gorpUtil.Get(t).Where(cs...)
}
func (t *{{.Type}}) Rel(m gorpUtil.Model, edge string) *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(m, edge)
}
func (t *{{.Type}}) Rels(rs ...*gorpUtil.Relation) *gorpUtil.Query {
	return gorpUtil.Get(t).Rels(rs...)
}
{{- if .Rels}}
// Relations
{{- range $edge, $rel := .Rels}}
func (t *{{$dot.Type}}) Rel_{{$edge}}() *gorpUtil.Query {
	return gorpUtil.Get(t).Rel(new({{$rel.Name}}), "{{$edge}}")
}
{{- end}}
{{end}}

// json string
func (t *{{$dot.Type}}) String() string {
    bs, _ := json.Marshal(t)
    return string(bs)
}

// pagination
type {{$dot.Type}}PageResp struct {
	*gorpUtil.PageResponse
	Data []*{{$dot.Type}} ` + "`" + `db:"data" json:"data"` + "`" + `
}

func (t *{{$dot.Type}}PageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func Load{{$dot.Type}}Page(tx gorp.SqlExecutor, resp *{{$dot.Type}}PageResp, q *gorpUtil.Query, page *gorpUtil.Page) error {
	resp.Data = make([]*{{$dot.Type}}, 0)
	total, err := gorpUtil.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = gorpUtil.NewPageResponse(page, total, resp.Data)
	return nil
}
`
